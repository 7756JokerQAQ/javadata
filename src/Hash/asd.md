## 什么是哈希表
每一个字符和一个索引相对应  O(1)级别的查找操作！
也很难保持每一个键 通过哈希函数的转换对应不同的索引 这里就产生了哈希冲突
哈希函数的设计  如何解决哈希冲突
哈希表充分体现了算法设计领域的经典思想：空间换时间
键通过哈希函数得到的索引分布越均匀越好

哈希函数的设计
整型：小范围正整数直接使用  
小范围负整数进行偏移  -100~100 ---> 0~200
大整数 ：身份证号 112032130120321321
通常做法 ：取模运算 ，比如取后四位。等同于mod10000 可能导致分布不均匀没有利用所有的信息
一个简单的解决方法：取模一个素数 可以有效的避免大部分哈希冲突

浮点型
在计算机中都是32或者64位的二进制表示，只不过计算机解析成了浮点数
字符串
所占的空间不固定 --->转换为整型来处理
161=1*10^2+6*10+6*10^0
code=c*26^3+o*26^2+d*26^1+e*26^0
code=c*B^3+o*B^2+d*B^1+e*B^0
hash(code)=code%M
hash(code)=((((c*B)+o)*B+d)*B+e)%M
hash(code)=(((((c%M)*B)+o)%M*B+d)%M*B+e)%M   //复合类型
哈希函数的设计：字符串类型
int hash=0;
for(int i=0;i<s.length();i++){
hash=(hash*B+s.charAt(i))%M
}
Data:year,month,day
hash(date)=(((date.year%M)*B+date.month)%M*B+date.day)%M
总而言之均转换为整形处理，但这个不是唯一的方法 
原则：
1.一致性：如果a==b则hash（a）==hash（b）
2.高效性：计算高效简便
3.均匀性：哈希值均匀分布

注意：Java中含有hashCode函数

hash冲突的处理 ：链地址法   
HashMap就是一个TreeMap\HashSet就是一个TreeSet
当哈希冲突达到一定程度的时候每一个位置从链表转成红黑树

总共有M个地址
如果放入哈希表的元素为N 如果每个地址是链表：O(N/M) 如果每个地址是平衡树：O(log(N/M))

哈希表的动态空间处理
平均每个地址承载的元素多过一定的程度，即扩容
平均每个地址承载的元素少过一定的程度，即缩容

哈希表的复杂度分析 平均复杂度为O(1)

对于哈希表来说，元素从N增加到upperTol*N；地址空间增倍 平均复杂度为O(1)
其实每个操作在O(lowerTol)~O(upperTol)--->O(1)
缩容同理
